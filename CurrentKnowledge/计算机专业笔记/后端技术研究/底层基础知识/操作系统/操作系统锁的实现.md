# 操作系统锁的实现

为保证数据操作的一致性，操作系统引入锁机制保证临界区代码的安全。

锁拥有两种状态：空闲状态和上锁状态，加锁时需要判断所是否为空闲状态，如果空闲，修改为上锁状态，返回成功，如果已上锁，则返回失败，解锁时则把上锁状态修改为空闲状态。

然而，如果操作系统不提供一些特殊手段，当中断发生时或者多核情况下会导致两个线程同时获取到锁并进行对应的操作。
因此，在硬件层面，CPU提供了原子操作、关中断、锁内存总线（TSL）的机制；OS基于这几个CPU硬件机制，就能够实现锁；
再基于锁，就能够实现各种各样的同步机制（信号量、消息、Barrier等等）。

**test-and-set（TAS）**是原语操作，3条指令必须一次执行完毕

    bool test-and-set(*lock){
        bool old=*lock
        *lock=true
        return old
    }
    do{
        while(test-and-set(*lock)){
        
        }
        critical section  //临界区
        *lock=false
    }while(true)


**关中断**是实现互斥最简单的方法之一，在访问临界区之前执行关中断，那么在访问临界区的时候就不去响应中断，从而不会引发调度，也就不会发生进程或者线程切换，
该方法实现简单，但是滥用关中断可能会引发不可估计的后果，还会极大影响系统效率问题。
一方面给用户关中断的权力很危险，如果用户进程死循环，操作系统可能拥有无法获取控制权；另一方面，该方法只是用于单CPU的场景，其他CPU上运行的线程仍然可以访问临界资源，因为不同CPU有自己的时钟中断器。

**锁内存总线**（TSL）指的是当一个进程使用内存时另一个进程不能访问内存，即使是另一个CPU也不行，该方法弥补关中断在多核系统下的问题。

**自旋锁**（Spinlock）用一个忙标志`flag`表示锁是否被占用，当`flag=0`表示锁空闲，当一个线程成功将`flag`从`0`变为`1`时，表示该线程获得锁。
具体实现上，线程将在`while`循环中尝试通过TAS等硬件原子指令（Compare And Swap、Load-Link And Store-Conditional）获取锁。适用于线程持有锁的时间很短的场景。

**互斥锁**（Mutex）需要操作系统的帮助，当一个线程访问其他线程持有的锁时，会被 OS 调度为阻塞状态（休眠），直到锁被释放后，再唤醒一个休眠的线程。
互斥锁的开销主要体现在线程的重新调度和上下文切换上（系统调用，用户态到内核态切换），获取锁的开销是比较大的。因此 mutex 适用于线程持有锁时间比较长的场景。

**自适应锁**(Adaptive Mutex)先执行自旋锁，不断尝试获取锁，如果尝试多次还获取不到，就执行互斥锁操作，让线程进入睡眠，又称两阶段锁（Two-stage Lock）、混合锁（Hybrid Mutex）


# 死锁

死锁，指多个进程因抢夺资源而造成的一种僵局（互相等待，都处于阻塞状态），若无外力作用，这些进程将无法向前推进。

死锁产生的必要条件(四个条件缺一都不会发生死锁):
1. 互斥条件
2. 不剥夺条件
3. 请求并保持条件
4. 循环等待体哦阿健

死锁处理策略：死锁预防、避免死锁（系统安全状态、银行家算法）、死锁的检测及解除
